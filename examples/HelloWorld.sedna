import Int
import String
import Linux.StdStm
import Linux.Proc

Main() {
	Int a = 0

	for Int b = 0; b < 100; b++ {
		a += b
	}

	if a != 5050 {
		StdStm<Err>.Println("????? 5050 != " + a)
		Proc.Exit(Proc.Exit.FAILURE)
	}

	Y y = new Y()
	y.foo()
	y.bar()

	Y t = y

	Z<String, Int> z = new Z(a)
	try {
		z.print()
	} catch (E e) {
		StdStm<Out>.Println(e.GetMessage())
	}

	StdStm<Out>.Println("Hello World from Sedna!")
}

class X impl I {
	foo() {
		StdStm<Out>.Println("foo impl")
	}
}

class Y inher X {
	foo() {
		StdStm<Out>.Println("derived")
	}

	bar() {
		StdStm<Out>.Println("bar")
	}
}

interf I {
	foo()
}

excep E {}

class Z<T1, T2> {
	private T1 value
	private T2 value2

	Z(T2 t2) {
		this.value2 = t2
		StdStm<Out>.Println("Constructing with " + val)
	}

	set(T1 val) {
		value := val
	}

	(T1, T2) get() {
		ret (value, value2)
	}

	print() throws E {
		if value == null || value2 == null {
			throw E
		}

		StdStm<Out>.Println(value)
		StdStm<Out>.Println(value2)
	}
}

mod M {
	Int add(Int a, Int b) {
		ret a + b
	}

	Int mul(Int a, Int b) {
		ret a * b
	}

	String mulS(Int a, Int b) {
		ret mul(a, b)
	}

	(Int, Int) swapT((Int, Int) (a, b)) {
		ret (b, a)
	}

	(Int, Int) updateT((Int, Int) p(a, b), Int cnt) {
		ret (p.a + cnt, p.b + cnt)
	}
}
